<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Steve Good </title>
    <link>http://www.stevegood.rocks/tags/groovy/index.xml</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2016</rights>
    <updated>0001-01-01 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>Simple URL Monitor Using Groovy and Twilio</title>
          <link>http://www.stevegood.rocks/post/2012/08/23/simple-url-monitor-using-groovy-and-twilio/</link>
          <pubDate>Thu, 23 Aug 2012 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://www.stevegood.rocks/post/2012/08/23/simple-url-monitor-using-groovy-and-twilio/</guid>
          <description>&lt;p&gt;Recently, the need arose for me to monitor a URL so that notifications could be sent out if the site was suddenly unavailable. Later on down the road this will need to evolve into a more proactive system rather than reactive but for now I am just focusing on site down notifications.&lt;/p&gt;

&lt;p&gt;To start, I set some minimal requirements for myself.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Needs to be easy to write, can&amp;rsquo;t take more than an hour to build&lt;/li&gt;
&lt;li&gt;Needs to be easy to maintain, problems should be easy to find and fix&lt;/li&gt;
&lt;li&gt;Needs to be able to send SMS messages in case of outages&lt;/li&gt;
&lt;li&gt;Needs to be able to run standalone or on a server under cron&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When looking at the requirements I had to think about what kind of scripting environment would be best served for the task.  I had several options available to me each with pros and cons.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bash

&lt;ul&gt;
&lt;li&gt;Pros

&lt;ul&gt;
&lt;li&gt;Runs natively on any *nix based system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cons

&lt;ul&gt;
&lt;li&gt;Extremely verbose&lt;/li&gt;
&lt;li&gt;Will not run on non *nix based systems&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Perl

&lt;ul&gt;
&lt;li&gt;Pros

&lt;ul&gt;
&lt;li&gt;I would be able to drudge up ancient knowledge that I had buried deep in the catacombs of my mind&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cons

&lt;ul&gt;
&lt;li&gt;I don&amp;rsquo;t have enough time to drudge up my ancient, and dusty, knowledge of Perl&lt;/li&gt;
&lt;li&gt;I would spend too much time trying to figure out how to do everything in a single line of code&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Groovy

&lt;ul&gt;
&lt;li&gt;Pros

&lt;ul&gt;
&lt;li&gt;I work with Groovy every day at work&lt;/li&gt;
&lt;li&gt;I can use Grape to supply dependencies using the &lt;code&gt;@Grab&lt;/code&gt; annotation&lt;/li&gt;
&lt;li&gt;Code tends to be clean and simple&lt;/li&gt;
&lt;li&gt;Can be run on any system that has Groovy installed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cons

&lt;ul&gt;
&lt;li&gt;Must have Groovy installed&lt;/li&gt;
&lt;li&gt;It is a little slow to startup&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It should be no surprise that I chose to use Groovy for this project.  For me, Groovy just fits the bill better in terms of code verbosity and features available.&lt;/p&gt;

&lt;p&gt;Building the script was a snap.  One of the cool things about shell scripting is that you are able to specify the binary that you want to use to execute your script. So by adding a single line of declaration I was able to create a script that can run as if it was a native executable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env groovy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that it&amp;rsquo;s just a matter of writing the code that does the work!  Lets start with the dependent libraries.&lt;/p&gt;

&lt;p&gt;First I needed to make sure I had the HTTP-Builder library.  Grape makes this a snap to get by letting me take advantage of the &lt;code&gt;@Grab&lt;/code&gt; annotation. I just place the following towards the top of my script and like magic everything I need is available.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;@Grab(group=&#39;org.codehaus.groovy.modules.http-builder&#39;, module=&#39;http-builder&#39;, version=&#39;0.5.2&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also need to make sure I have the Apache commons httpclient libraries.  I use another &lt;code&gt;@Grab&lt;/code&gt; to do this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;@Grab(group=&#39;commons-httpclient&#39;,module=&#39;commons-httpclient&#39;,version=&#39;3.1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Grape is actually going out to the maven repositories and downloading the jars I requested and adding them to my classpath.  Pretty slick eh?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll skip the imports (but you can check out the full source if those kinds of things excite you) and just straight to the guts of the script.&lt;/p&gt;

&lt;p&gt;Next, among other things, I wanted to make sure that the script was configurable enough that I could add a list of phone numbers and be able to easily specify the url to monitor. To do that I created a nice little HashMap of key value pairs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def now = new Date()
def options = [
  server: &amp;quot;https://google.com/&amp;quot;,
  intervalSeconds: 600,
  sid: &amp;quot;&amp;quot;,
  authToken: &amp;quot;&amp;quot;,
  fromPhone: &amp;quot;&amp;quot;,
  toPhone: &amp;quot;&amp;quot;,
  smsOnStart: false,
  smsOnStartMessage: &amp;quot;Site monitoring script started at ${now.format(&#39;H:mm:ss&#39;)} on ${now.format(&#39;yyyy-MM-dd&#39;)}&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, so options are great, but without some functionality they really mean nothing. Next I define two functions.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the method that sends the SMS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def sendSMS(def message, def opts){
  if (opts.sid != &amp;quot;&amp;quot; &amp;amp;&amp;amp; opts.authToken != &amp;quot;&amp;quot; &amp;amp;&amp;amp; message != &amp;quot;&amp;quot;){
    String twilioHost = &amp;quot;api.twilio.com&amp;quot;
    String sid = opts.sid
    String authToken = opts.authToken

    def hc = new HostConfiguration()
    hc.setHost(twilioHost, 443, &amp;quot;https&amp;quot;)
    def url = &amp;quot;/2010-04-01/Accounts/$sid/SMS/Messages&amp;quot;

    def client = new HttpClient()
    Credentials defaultcreds = new UsernamePasswordCredentials(sid, authToken)
    client.getState().setCredentials(null, null, defaultcreds)

    opts.toPhone.split(&#39;,&#39;)?.each { toPhn -&amp;gt;
      PostMethod postMethod = new PostMethod(url)
      postMethod.addParameter(&amp;quot;IfMachine&amp;quot;,&amp;quot;Continue&amp;quot;)
      postMethod.addParameter(&amp;quot;Method&amp;quot;,&amp;quot;POST&amp;quot;)
      postMethod.addParameter(&amp;quot;From&amp;quot;,opts.fromPhone)
      postMethod.addParameter(&amp;quot;To&amp;quot;,toPhn)
      postMethod.addParameter(&amp;quot;Body&amp;quot;,message)

      client.executeMethod(hc, postMethod)

      postMethod.releaseConnection()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the method that checks the status of the url.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def doPing(def opts) {
  if (opts.server != &amp;quot;&amp;quot;){
    try {
      new HTTPBuilder( opts.server ).get( path:&#39;&#39; ) { response -&amp;gt;
        def msg = &amp;quot;&amp;quot;
        if (response.statusLine.statusCode == 200){
          msg = &amp;quot;${new Date()} :: UP!&amp;quot;
          println msg
        } else {
          msg = &amp;quot;${new Date()} :: There might be a production problem! -&amp;gt; ${response.statusLine.statusCode}&amp;quot;
          println msg
          sendSMS(msg,opts)
        }
      }
    } catch( e ){
      println &amp;quot;${new Date()}&amp;quot;
      e.printStackTrace()
      sendSMS(&amp;quot;There was an error when connecting to the production server, it might be down.&amp;quot;,opts)
    }

    if (opts.intervalSeconds &amp;gt; 0){
      def then = new Date()
      then.seconds += opts.intervalSeconds
      println &amp;quot;Checking again at ${then}&amp;quot;
      while (new Date() &amp;lt;= then){
        // do nothing
      }

      doPing( opts )
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since these are both method declarations and they won&amp;rsquo;t just call themselves we need to do one last thing, call the doPing method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;if (options.smsOnStart){
  sendSMS(options.smsOnStartMessage,options)
}

doPing( options )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s the whole script! If you are interested in looking at or using the script &lt;a href=&#34;https://github.com/stevegood/groovy-url-monitor&#34;&gt;Github&amp;rsquo;s&lt;/a&gt; going to be the best place to do that. With comments and code the whole thing come to a mere 106 lines of code! Not bad for something that monitors a URL and then sends an SMS when there is a problem.&lt;/p&gt;

&lt;p&gt;I know I glossed over how the methods actually work but I felt they were pretty self explanatory. Feel free to ask questions in the comments if you would like further explanation.&lt;/p&gt;

&lt;p&gt;Thanks for reading!&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
