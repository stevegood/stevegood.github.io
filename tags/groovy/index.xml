<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Groovy on Steve Good</title>
    <link>http://www.stevegood.rocks/tags/groovy/index.xml</link>
    <description>Recent content in Groovy on Steve Good</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://www.stevegood.rocks/tags/groovy/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Implementing Caffeine Cache with Spring Boot</title>
      <link>http://www.stevegood.rocks/post/2016/11/15/implementing-caffeine-cache-with-spring-boot/</link>
      <pubDate>Tue, 15 Nov 2016 14:55:39 -0800</pubDate>
      
      <guid>http://www.stevegood.rocks/post/2016/11/15/implementing-caffeine-cache-with-spring-boot/</guid>
      <description>

&lt;p&gt;Implementing a cache, even a basic one, used to require lots of architectural discussion, meetings, evaluations, and a significant amount of development time. With &lt;a href=&#34;http://projects.spring.io/spring-boot/&#34;&gt;Spring Boot&lt;/a&gt;, those days are far behind us! With a small amount of configuration, dependency management, and a few annotations any developer can have caching set up in their application in a few minutes.&lt;/p&gt;

&lt;h2 id=&#34;generating-a-new-application&#34;&gt;Generating a new application&lt;/h2&gt;

&lt;p&gt;Using either the &lt;a href=&#34;http://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-sdkman-cli-installation&#34;&gt;Spring Boot CLI&lt;/a&gt; or the &lt;a href=&#34;https://start.spring.io&#34;&gt;Spring Initializr&lt;/a&gt;, create a new application using the following (unless specified, use the defaults):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gradle Project

&lt;ul&gt;
&lt;li&gt;You could use Maven also, just replace the &lt;code&gt;./gradlew&lt;/code&gt; commands with &lt;code&gt;mvn&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Version: &lt;em&gt;1.4.2&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;Higher versions should also work, this was just the most current version as of this writing&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Language: &lt;em&gt;Groovy&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;Not required but I prefer writing less verbose code&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Packages

&lt;ul&gt;
&lt;li&gt;Cache &lt;em&gt;(Core)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Web &lt;em&gt;(Web)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Thymeleaf &lt;em&gt;(Template Engines)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;write-a-simple-web-app&#34;&gt;Write a simple web app&lt;/h2&gt;

&lt;p&gt;For this demo we are going to build a simple HTML page that displays the current time. Exciting right?! For this, we will need a build a controller and a view.&lt;/p&gt;

&lt;h3 id=&#34;the-controller-and-the-view&#34;&gt;The controller and the view&lt;/h3&gt;

&lt;p&gt;Create a new Groovy class in the &lt;code&gt;com.example&lt;/code&gt; package named &lt;strong&gt;TimeController&lt;/strong&gt; with the following content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;package com.example

import org.springframework.stereotype.Controller
import org.springframework.ui.Model
import org.springframework.web.bind.annotation.RequestMapping

@Controller
class TimeController {
    
    @RequestMapping
    def index(Model model) {
        model.addAllAttributes now: (new Date().time)
        &#39;index&#39;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, create the view in &lt;code&gt;src/main/resources/templates&lt;/code&gt; directory and named &lt;strong&gt;index.html&lt;/strong&gt; with the following content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Caffeine Cache Demo&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p th:text=&amp;quot;&#39;Now: &#39; + ${now}&amp;quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;run-the-application&#34;&gt;Run the application&lt;/h3&gt;

&lt;p&gt;From a terminal, use the Gradle wrapper to start the application.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;./gradlew bootRun&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Once the application has started up, you should be able to view it running at &lt;a href=&#34;http://localhost:8080/&#34;&gt;localhost:8080&lt;/a&gt;. The page should show the current time in milliseconds.  Each time you refresh the page the time should be updated.&lt;/p&gt;

&lt;h2 id=&#34;add-basic-cache-functionality&#34;&gt;Add basic cache functionality&lt;/h2&gt;

&lt;p&gt;We already added the dependency for Spring Cache all we need to do now is enable the cache and cache something. This is the easy part. Well, all of it is the easy part.&lt;/p&gt;

&lt;h3 id=&#34;enable-caching&#34;&gt;Enable caching&lt;/h3&gt;

&lt;p&gt;Modify &lt;code&gt;com.example.DemoApplication&lt;/code&gt; so that it matches the following (note the &lt;code&gt;@EnableCaching&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;package com.example

import org.springframework.boot.SpringApplication
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.cache.annotation.EnableCaching

@SpringBootApplication
@EnableCaching
class DemoApplication {

	static void main(String[] args) {
		SpringApplication.run DemoApplication, args
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-a-service-for-getting-time&#34;&gt;Create a service for getting time&lt;/h3&gt;

&lt;p&gt;We want to better encapsulate how our application gets time. This will help us apply caching in a more organized way.&lt;/p&gt;

&lt;p&gt;Create a Groovy class in the &lt;code&gt;com.example&lt;/code&gt; package named &lt;strong&gt;TimeService&lt;/strong&gt; with the following content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;package com.example

import org.springframework.stereotype.Service

@Service
class TimeService {

    long getTimeNow() {
        new Date().time
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modify the &lt;code&gt;com.example.TimeController&lt;/code&gt; class to get the current time from the TimeService. Note the addition of &lt;code&gt;TimeService&lt;/code&gt; being autowired as well as the call to &lt;code&gt;timeService.timeNow&lt;/code&gt; in the map of attributes being added to the model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;package com.example

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Controller
import org.springframework.ui.Model
import org.springframework.web.bind.annotation.RequestMapping

@Controller
class TimeController {

    @Autowired
    TimeService timeService

    @RequestMapping
    def index(Model model) {
        model.addAllAttributes now: timeService.timeNow
        &#39;index&#39;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;add-a-cached-method&#34;&gt;Add a cached method&lt;/h3&gt;

&lt;p&gt;Running the application at this point will yield the same behavior we had previously. We have not added anything to that needs to be cached. Lets do that now. In the &lt;code&gt;com.example.TimeService&lt;/code&gt; class add a new method named &lt;em&gt;getTimeCached&lt;/em&gt; and have it return a call to &lt;em&gt;getTimeNow&lt;/em&gt;. Lets also add a new annotation, &lt;code&gt;@Cacheable&lt;/code&gt; to the method that tells Spring Boot to cache the results of the method. It should now look like the following.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;package com.example

import org.springframework.cache.annotation.Cacheable
import org.springframework.stereotype.Service

@Service
class TimeService {

    long getTimeNow() {
        new Date().time
    }
    
    @Cacheable(&#39;timeCached&#39;)
    long getTimeCached() {
        timeNow
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By adding the &lt;code&gt;@Cacheable&lt;/code&gt; annotation to the method, we are instructing Spring Boot to manage a HashMap cache with the method&amp;rsquo;s result. The name &lt;em&gt;timeCached&lt;/em&gt; in the annotation is the name of the cache key we want to use. This makes things easier when you want to manipulate specific cached data.&lt;/p&gt;

&lt;h3 id=&#34;use-the-cached-method-and-render-the-result-in-the-view&#34;&gt;Use the cached method and render the result in the view&lt;/h3&gt;

&lt;p&gt;The last step is to start using the new method and render its result in the view. Back in the &lt;code&gt;com.example.TimeController&lt;/code&gt; class, add a new key to the attributes map.  It should now look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;model.addAllAttributes now: timeService.timeNow, cached: timeService.timeCached
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in &lt;code&gt;src/resources/templates/index.html&lt;/code&gt; add the following line above the closing &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p th:text=&amp;quot;&#39;Cached: &#39; + ${cached}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-it-out&#34;&gt;Test it out&lt;/h3&gt;

&lt;p&gt;Restart the application and refresh the page in your browser.  You&amp;rsquo;ll notice that in addition to the time now we are also showing the cached time. If you refresh the page only the time now will change and the cached time will stay the same indefinitely. Congratulations, now you&amp;rsquo;re caching with ease!&lt;/p&gt;

&lt;h2 id=&#34;improve-caching-with-caffeine&#34;&gt;Improve caching with Caffeine&lt;/h2&gt;

&lt;p&gt;Having a cache that lives for the life of the application might fit your use case but it also comes with some issues. What if the data you are caching changes over time? What if you want to control the size of the cache? In this section, we are going to implement a cache library called &lt;a href=&#34;https://github.com/ben-manes/caffeine&#34;&gt;Caffeine&lt;/a&gt;. Caffeine is an in-memory cache aimed at replacing Google&amp;rsquo;s Guava. It is high performance and light weight, perfect for our simple application.&lt;/p&gt;

&lt;h3 id=&#34;add-the-caffeine-library-to-the-application&#34;&gt;Add the Caffeine library to the application&lt;/h3&gt;

&lt;p&gt;In your &lt;code&gt;build.gradle&lt;/code&gt; file, add the following line to the &lt;em&gt;dependencies&lt;/em&gt; block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;compile &#39;com.github.ben-manes.caffeine:caffeine:2.3.5&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maven users can add the following to their &lt;code&gt;pom.xml&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.ben-manes.caffeine&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;caffeine&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.3.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Technically that is all you need to do for Spring Boot to start using Caffeine as the cache provider. However, it will operate exactly the same as before. Lets add some configuration to override the default behavior.&lt;/p&gt;

&lt;h3 id=&#34;configure-caffeine&#34;&gt;Configure Caffeine&lt;/h3&gt;

&lt;p&gt;By default Spring Boot comes with a configuration file named &lt;em&gt;application.properties&lt;/em&gt; in the &lt;code&gt;src/resources&lt;/code&gt; directory. I am not a fan of typing the same words over and over again so I prefer to use YAML (you can read more about Spring Boot&amp;rsquo;s configuration files on its project page). Start by renaming &lt;em&gt;application.properties&lt;/em&gt; to &lt;em&gt;application.yml&lt;/em&gt;. Spring Boot will automatically recognize this as a valid configuration file. Open the file and add the following content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  cache:
    cache-names: timeCached
    caffeine:
      spec: expireAfterAccess=30s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This bit of configuration instructs Spring Boot to configure Caffeine with a cache named &lt;em&gt;timeCached&lt;/em&gt; that expires after 30 seconds of inactivity.&lt;/p&gt;

&lt;h3 id=&#34;run-it&#34;&gt;Run it&lt;/h3&gt;

&lt;p&gt;Restart the application (if it is still running) and navigate to &lt;a href=&#34;http://localhost:8080/&#34;&gt;localhost:8080&lt;/a&gt;.  You&amp;rsquo;ll see the same output as the last time we checked in on our application. Refresh the page a few times to verify that we are still caching the time. Now, wait 30 or more seconds and try refreshing the page. You should see that the cached time has been updated. Refresh a few more times to verify that the new time has been cached.&lt;/p&gt;

&lt;h3 id=&#34;use-a-better-eviction-policy&#34;&gt;Use a better eviction policy&lt;/h3&gt;

&lt;p&gt;Great, we have a cache that expires after 30 seconds. Or does it? Re-read that last paragraph. You will note that I mentioned the cache will expire after 30 seconds of inactivity. This means that if the cache is written to or read from at any point during those 30 seconds the eviction timer will reset. This will quickly turn into a cache that appears to never expire in applications that access the cache more frequently that the eviction policy dictates. This could be bad. What we really want, is a cache that expires 30 seconds after it has been written. Lets make a small tweak to the &lt;em&gt;application.yml&lt;/em&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  cache:
    cache-names: timeCached
    caffeine:
      spec: expireAfterWrite=30s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this change the cache data will be evicted 30 seconds after it has been written. You can read more about &lt;a href=&#34;https://github.com/ben-manes/caffeine/wiki/Eviction&#34;&gt;eviction policies&lt;/a&gt; on the Caffeine wiki.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Congratulations, you made it! You have a simple application that caches some data with a time based eviction policy. Spring Boot supports a number of different caching providers including, EHCache, Redis, and Hazlecast. Most of these can be configured in a similar way but all of them will leverage the same implementation in your code. The &lt;code&gt;@Cacheable&lt;/code&gt; and &lt;code&gt;@EnableCaching&lt;/code&gt; annotations abstract away the implementation details so that you can focus on your application and the minimal configuration. Also, if you got stuck anywhere, feel free to refer back to the &lt;a href=&#34;https://github.com/stevegood/caffeine-cache-spring-boot-demo&#34;&gt;finished sample application on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Good luck and happy caching!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple URL Monitor Using Groovy and Twilio</title>
      <link>http://www.stevegood.rocks/post/2012/08/23/simple-url-monitor-using-groovy-and-twilio/</link>
      <pubDate>Thu, 23 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.stevegood.rocks/post/2012/08/23/simple-url-monitor-using-groovy-and-twilio/</guid>
      <description>&lt;p&gt;Recently, the need arose for me to monitor a URL so that notifications could be sent out if the site was suddenly unavailable. Later on down the road this will need to evolve into a more proactive system rather than reactive but for now I am just focusing on site down notifications.&lt;/p&gt;

&lt;p&gt;To start, I set some minimal requirements for myself.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Needs to be easy to write, can&amp;rsquo;t take more than an hour to build&lt;/li&gt;
&lt;li&gt;Needs to be easy to maintain, problems should be easy to find and fix&lt;/li&gt;
&lt;li&gt;Needs to be able to send SMS messages in case of outages&lt;/li&gt;
&lt;li&gt;Needs to be able to run standalone or on a server under cron&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When looking at the requirements I had to think about what kind of scripting environment would be best served for the task.  I had several options available to me each with pros and cons.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bash

&lt;ul&gt;
&lt;li&gt;Pros

&lt;ul&gt;
&lt;li&gt;Runs natively on any *nix based system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cons

&lt;ul&gt;
&lt;li&gt;Extremely verbose&lt;/li&gt;
&lt;li&gt;Will not run on non *nix based systems&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Perl

&lt;ul&gt;
&lt;li&gt;Pros

&lt;ul&gt;
&lt;li&gt;I would be able to drudge up ancient knowledge that I had buried deep in the catacombs of my mind&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cons

&lt;ul&gt;
&lt;li&gt;I don&amp;rsquo;t have enough time to drudge up my ancient, and dusty, knowledge of Perl&lt;/li&gt;
&lt;li&gt;I would spend too much time trying to figure out how to do everything in a single line of code&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Groovy

&lt;ul&gt;
&lt;li&gt;Pros

&lt;ul&gt;
&lt;li&gt;I work with Groovy every day at work&lt;/li&gt;
&lt;li&gt;I can use Grape to supply dependencies using the &lt;code&gt;@Grab&lt;/code&gt; annotation&lt;/li&gt;
&lt;li&gt;Code tends to be clean and simple&lt;/li&gt;
&lt;li&gt;Can be run on any system that has Groovy installed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cons

&lt;ul&gt;
&lt;li&gt;Must have Groovy installed&lt;/li&gt;
&lt;li&gt;It is a little slow to startup&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It should be no surprise that I chose to use Groovy for this project.  For me, Groovy just fits the bill better in terms of code verbosity and features available.&lt;/p&gt;

&lt;p&gt;Building the script was a snap.  One of the cool things about shell scripting is that you are able to specify the binary that you want to use to execute your script. So by adding a single line of declaration I was able to create a script that can run as if it was a native executable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env groovy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that it&amp;rsquo;s just a matter of writing the code that does the work!  Lets start with the dependent libraries.&lt;/p&gt;

&lt;p&gt;First I needed to make sure I had the HTTP-Builder library.  Grape makes this a snap to get by letting me take advantage of the &lt;code&gt;@Grab&lt;/code&gt; annotation. I just place the following towards the top of my script and like magic everything I need is available.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;@Grab(group=&#39;org.codehaus.groovy.modules.http-builder&#39;, module=&#39;http-builder&#39;, version=&#39;0.5.2&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also need to make sure I have the Apache commons httpclient libraries.  I use another &lt;code&gt;@Grab&lt;/code&gt; to do this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;@Grab(group=&#39;commons-httpclient&#39;,module=&#39;commons-httpclient&#39;,version=&#39;3.1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Grape is actually going out to the maven repositories and downloading the jars I requested and adding them to my classpath.  Pretty slick eh?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll skip the imports (but you can check out the full source if those kinds of things excite you) and just straight to the guts of the script.&lt;/p&gt;

&lt;p&gt;Next, among other things, I wanted to make sure that the script was configurable enough that I could add a list of phone numbers and be able to easily specify the url to monitor. To do that I created a nice little HashMap of key value pairs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def now = new Date()
def options = [
  server: &amp;quot;https://google.com/&amp;quot;,
  intervalSeconds: 600,
  sid: &amp;quot;&amp;quot;,
  authToken: &amp;quot;&amp;quot;,
  fromPhone: &amp;quot;&amp;quot;,
  toPhone: &amp;quot;&amp;quot;,
  smsOnStart: false,
  smsOnStartMessage: &amp;quot;Site monitoring script started at ${now.format(&#39;H:mm:ss&#39;)} on ${now.format(&#39;yyyy-MM-dd&#39;)}&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, so options are great, but without some functionality they really mean nothing. Next I define two functions.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the method that sends the SMS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def sendSMS(def message, def opts){
  if (opts.sid != &amp;quot;&amp;quot; &amp;amp;&amp;amp; opts.authToken != &amp;quot;&amp;quot; &amp;amp;&amp;amp; message != &amp;quot;&amp;quot;){
    String twilioHost = &amp;quot;api.twilio.com&amp;quot;
    String sid = opts.sid
    String authToken = opts.authToken

    def hc = new HostConfiguration()
    hc.setHost(twilioHost, 443, &amp;quot;https&amp;quot;)
    def url = &amp;quot;/2010-04-01/Accounts/$sid/SMS/Messages&amp;quot;

    def client = new HttpClient()
    Credentials defaultcreds = new UsernamePasswordCredentials(sid, authToken)
    client.getState().setCredentials(null, null, defaultcreds)

    opts.toPhone.split(&#39;,&#39;)?.each { toPhn -&amp;gt;
      PostMethod postMethod = new PostMethod(url)
      postMethod.addParameter(&amp;quot;IfMachine&amp;quot;,&amp;quot;Continue&amp;quot;)
      postMethod.addParameter(&amp;quot;Method&amp;quot;,&amp;quot;POST&amp;quot;)
      postMethod.addParameter(&amp;quot;From&amp;quot;,opts.fromPhone)
      postMethod.addParameter(&amp;quot;To&amp;quot;,toPhn)
      postMethod.addParameter(&amp;quot;Body&amp;quot;,message)

      client.executeMethod(hc, postMethod)

      postMethod.releaseConnection()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the method that checks the status of the url.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def doPing(def opts) {
  if (opts.server != &amp;quot;&amp;quot;){
    try {
      new HTTPBuilder( opts.server ).get( path:&#39;&#39; ) { response -&amp;gt;
        def msg = &amp;quot;&amp;quot;
        if (response.statusLine.statusCode == 200){
          msg = &amp;quot;${new Date()} :: UP!&amp;quot;
          println msg
        } else {
          msg = &amp;quot;${new Date()} :: There might be a production problem! -&amp;gt; ${response.statusLine.statusCode}&amp;quot;
          println msg
          sendSMS(msg,opts)
        }
      }
    } catch( e ){
      println &amp;quot;${new Date()}&amp;quot;
      e.printStackTrace()
      sendSMS(&amp;quot;There was an error when connecting to the production server, it might be down.&amp;quot;,opts)
    }

    if (opts.intervalSeconds &amp;gt; 0){
      def then = new Date()
      then.seconds += opts.intervalSeconds
      println &amp;quot;Checking again at ${then}&amp;quot;
      while (new Date() &amp;lt;= then){
        // do nothing
      }

      doPing( opts )
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since these are both method declarations and they won&amp;rsquo;t just call themselves we need to do one last thing, call the doPing method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;if (options.smsOnStart){
  sendSMS(options.smsOnStartMessage,options)
}

doPing( options )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s the whole script! If you are interested in looking at or using the script &lt;a href=&#34;https://github.com/stevegood/groovy-url-monitor&#34;&gt;Github&amp;rsquo;s&lt;/a&gt; going to be the best place to do that. With comments and code the whole thing come to a mere 106 lines of code! Not bad for something that monitors a URL and then sends an SMS when there is a problem.&lt;/p&gt;

&lt;p&gt;I know I glossed over how the methods actually work but I felt they were pretty self explanatory. Feel free to ask questions in the comments if you would like further explanation.&lt;/p&gt;

&lt;p&gt;Thanks for reading!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>